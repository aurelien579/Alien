struct kpages_bitmap {
    u32 frame_c;    /* total frame count */
    u32 base;       /* base adress */
    u32 bmp_s;      /* bitmap size in bytes */
    u8 *bmp;        /* bitmap */
};

static struct kpages_bitmap kheap;

static int
map_page(struct pd* dir, u32 frame, u32 virt, u8 flags);

static inline int
kheap_is_free(vaddr_t addr)
{
    addr = (addr - kheap.base) >> 12;
    return (kheap.bmp[(addr)/8] & (1 << (addr % 8))) == 0;
}

static inline void
kheap_setused(vaddr_t addr)
{
    addr = (addr - kheap.base) / PAGE_SIZE;
    kheap.bmp[(addr)/8] |= (1 << (addr % 8));
}

static inline void
kheap_free(vaddr_t addr)
{
    addr = (addr - kheap.base) >> 12;
    kheap.bmp[(addr)/8] &= ~(1 << (addr % 8));
}

vaddr_t
find_free_page(vaddr_t page)
{
    if (page >= kheap.base + kheap.frame_c * PAGE_SIZE)
        return 0;

    if (page % PAGE_SIZE != 0)
        return 0;

    if (page < kheap.base)
        page = kheap.base;

    while (!kheap_is_free(page)) {
        page += PAGE_SIZE;
        if (page >= kheap.base + kheap.frame_c * PAGE_SIZE)
            return 0;
    }

    return page;
}

static struct pd __attribute__ ((aligned (4096))) kpd;
static struct pd* current_pd;

/**
 * Allocate a page on the bitmap without mapping it
 */
static vaddr_t
__kalloc_page()
{
    vaddr_t page;

    if ((page = find_free_page(kheap.base)) == 0)
        return 0;

    kheap_setused(page);

    kprintf("__alloc_page : 0x%x\n", page);

    return page;
}

vaddr_t
kalloc_page()
{
    vaddr_t page;

    if ((page = __kalloc_page()) == 0)
        return 0;

    if (map_page(&kpd, page - kinfo.vbase, page, PE_PRESENT | PE_RW))
        return 0;

    return page;
}


vaddr_t
kalloc_pages(u32 n)
{
    vaddr_t page = 0;
    u8 valid = 0;

    while (!valid) {
        page = find_free_page(page + PAGE_SIZE);
        valid = 1;
        for (u32 i = 0; i < n; i++)
            if (!kheap_is_free(page + i * PAGE_SIZE))
                valid = 0;
    }

    for (u32 i = 0; i < n; i++) {
        kheap_setused(page + i * PAGE_SIZE);

        if (map_page(&kpd,
                 page + i * PAGE_SIZE - kinfo.vbase,
                 page + i * PAGE_SIZE,
                 PE_PRESENT | PE_RW) < 0)
            return 0;
    }

    return page;
}

static void
init_kbitmap()
{
    /* Initialize bitmap */
    kheap.frame_c = updiv(kinfo.memlen - kinfo.len, PAGE_SIZE);

    /* Keep some space for the bitmap */
    kheap.frame_c -= updiv(updiv(kheap.frame_c, 8), PAGE_SIZE);

    kheap.bmp_s = updiv(kheap.frame_c, 8);

    kheap.bmp = (u8*) (kinfo.len + kinfo.vbase);
    kheap.base = (u32) kheap.bmp + kheap.bmp_s * sizeof(u8);

    align(kheap.base, PAGE_SIZE);
}

/**
 * Identity map [0x0; kernel_end] -> [0xC0000000; 0xC0000000 + kernel_end]
 */
void
init_paging()
{
    u32 base;
    u32 kpt_c;
    u32 kernel_frame_c;

    init_kbitmap();

    kpt_c = updiv((kheap.base - kinfo.vbase), (PAGE_SIZE * 1024));
    kernel_frame_c = updiv((kheap.base - kinfo.vbase), PAGE_SIZE);
    kernel_frame_c += kpt_c;

    for (u32 i = PD_INDEX(kinfo.vbase); i < PD_INDEX(kinfo.vbase) + kpt_c; i++) {
        if ((base = __kalloc_page()) == 0)
            panic("kheap_alloc error\n");

        memset(base, 0, 4096);

        kpd.entries[i].base = (base - kinfo.vbase) >> 12;
        kpd.entries[i].flags = PE_PRESENT | PE_RW;
    }

    for (u32 i = 0; i < kernel_frame_c; i++)
        if (map_page(&kpd,
                    i * PAGE_SIZE,
                    i * PAGE_SIZE + kinfo.vbase,
                    PE_PRESENT | PE_RW) < 0)
            panic("map_page error\n");

    switch_page_dir(&kpd);
}

void
switch_page_dir(struct pd* dir)
{
    extern void __switch_page_dir(paddr_t addr);

    __switch_page_dir(paddr((vaddr_t) dir));

    current_pd = dir;
}

/**
 * return -1 if page table not present
 */
static int
map_page(struct pd* dir, u32 frame, u32 virt, u8 flags)
{
    struct pt* table;

    if ((dir->entries[PD_INDEX(virt)].flags & PE_PRESENT) == 0)
        return -1;

    table = (struct pt*) ((dir->entries[PD_INDEX(virt)].base << 12)
            + kinfo.vbase);

    table->entries[PT_INDEX(virt)].flags = flags;
    table->entries[PT_INDEX(virt)].base = (frame & 0xFFFFF000) >> 12;

    return 0;
}
